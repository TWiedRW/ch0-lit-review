<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Chapter 0</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="final_files/libs/clipboard/clipboard.min.js"></script>
<script src="final_files/libs/quarto-html/quarto.js"></script>
<script src="final_files/libs/quarto-html/popper.min.js"></script>
<script src="final_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="final_files/libs/quarto-html/anchor.min.js"></script>
<link href="final_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="final_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="final_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="final_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="final_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="final_files/libs/quarto-diagram/mermaid.min.js"></script>
<script src="final_files/libs/quarto-diagram/mermaid-init.js"></script>
<link href="final_files/libs/quarto-diagram/mermaid.css" rel="stylesheet">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Chapter 0</h1>
<p class="subtitle lead">Literature Review</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The practice of visualizing data is a key component of understanding data structures and communicating results. These visualizations are created by mapping data summaries into a visual space <span class="citation" data-cites="wilkinson2005">(<a href="#ref-wilkinson2005" role="doc-biblioref">Wilkinson and Wills 2005</a>)</span>, which in turn help readers to better understand data than compared to tables <span class="citation" data-cites="dallenbach1963 meyer1997 brewer2012">(<a href="#ref-dallenbach1963" role="doc-biblioref">Dallenbach 1963</a>; <a href="#ref-meyer1997" role="doc-biblioref">Meyer, Shinar, and Leiser 1997</a>; <a href="#ref-brewer2012" role="doc-biblioref">Brewer et al. 2012</a>)</span>. However, charts are not created equally and design considerations can help to improve numerical accuracy and comprehension <span class="citation" data-cites="croxton1932 cleveland1984">(<a href="#ref-croxton1932" role="doc-biblioref">Croxton and Stein 1932</a>; <a href="#ref-cleveland1984" role="doc-biblioref">Cleveland and McGill 1984</a>)</span> (ALSO CITE COMPREHENSION PAPER). In this dissertation, I will discuss the construction and evaluation of the projection of data visualizations.</p>
<p>(Probably will split this into a 2-3 paragraphs)</p>
<section id="design-of-data-visualizations" class="level2">
<h2 class="anchored" data-anchor-id="design-of-data-visualizations">Design of Data Visualizations</h2>
<p><span class="citation" data-cites="wilkinson2005">Wilkinson and Wills (<a href="#ref-wilkinson2005" role="doc-biblioref">2005</a>)</span> proposed the Grammar of Graphics, a systematic pipeline that maps data into charts. This process consists of taking a data source and aggregating data before taking the form of a visualization. While <span class="citation" data-cites="wilkinson2005">Wilkinson and Wills (<a href="#ref-wilkinson2005" role="doc-biblioref">2005</a>)</span> discusses a formulation of creating charts, a modified version is presented by <span class="citation" data-cites="wickham2010">Wickham (<a href="#ref-wickham2010" role="doc-biblioref">2010</a>)</span> to accommodate the practical needs for the programming aspect of the popular <code>ggplot2</code> package. Many other software packages make use of a similar process to create visualizations (js, Python, etc.)</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src=".png" class="img-fluid figure-img"></p>
<figcaption>Chart about GoG</figcaption>
</figure>
</div>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
    A[Data] --&gt; B(Variables)
    B --&gt; C(Algebra)
    C --&gt; D(Scales)
    D --&gt; E(Statistics)
    E --&gt; F(Geometry)
    F --&gt; G(Coordinates)
    G --&gt; H(Aesthetics)
    H --&gt; I[Render]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>All data visualizations start with underlying data and its variables <span class="citation" data-cites="wilkinson2005 wickham2010">(<a href="#ref-wilkinson2005" role="doc-biblioref">Wilkinson and Wills 2005, chaps. 3–7</a>; <a href="#ref-wickham2010" role="doc-biblioref">Wickham 2010</a>)</span>. (Variables, Algebra, Scales, Statistics) The data, whether it be in one table or multiple tables, contains variables that record measurements. These variables can be joined with other variables into a singular table. The final dataset is created when all appropriate scale transformations and statistical summaries are performed.</p>
<p>Once the data has been summarized, the visual components can be assigned <span class="citation" data-cites="wilkinson2005 wickham2010">(<a href="#ref-wilkinson2005" role="doc-biblioref">Wilkinson and Wills 2005, chaps. 8–10</a>; <a href="#ref-wickham2010" role="doc-biblioref">Wickham 2010</a>)</span>. (Geometry, Coordinates, Aesthetics, Render) Geometries are the first assignment, which denote how the data will be displayed. These geometries are placed into a coordinate system, which typically defaults to the Cartesian coordinate system. Aesthetics position the geometries onto the coordinate system and assign other attributes, such as colors and shapes. Lastly, the chart can be rendered to produce the visualization.</p>
</section>
<section id="chart-design-matters" class="level2">
<h2 class="anchored" data-anchor-id="chart-design-matters">Chart Design Matters</h2>
<p>In the 20th and 21st centuries, there were many studies conducted to determine which features of data visualizations are able to effectively communicate information to readers <span class="citation" data-cites="croxton1932 cleveland1984 kosslyn1989 heer2010">(<a href="#ref-croxton1932" role="doc-biblioref">Croxton and Stein 1932</a>; <a href="#ref-cleveland1984" role="doc-biblioref">Cleveland and McGill 1984</a>; <a href="#ref-kosslyn1989" role="doc-biblioref">Kosslyn 1989</a>; <a href="#ref-heer2010" role="doc-biblioref">Heer and Bostock 2010</a>)</span>. In general, simpler graphical elements tend to perform better on chart comprehension. <span class="citation" data-cites="cleveland1984">Cleveland and McGill (<a href="#ref-cleveland1984" role="doc-biblioref">1984</a>)</span> categorized these elements into <em>Elementary Perceptual Tasks</em>, which are methods that people use to extract quantitative information from charts. These methods include, but are not limited to, position along (non)-aligned scales, lengths, angles, areas, and volume.</p>
<p>The studies conducted by <span class="citation" data-cites="cleveland1984">Cleveland and McGill (<a href="#ref-cleveland1984" role="doc-biblioref">1984</a>)</span> provided a baseline for Elementary Perceptual Tasks, and their findings were replicated by <span class="citation" data-cites="heer2010">Heer and Bostock (<a href="#ref-heer2010" role="doc-biblioref">2010</a>)</span>. <span class="citation" data-cites="cleveland1984">Cleveland and McGill (<a href="#ref-cleveland1984" role="doc-biblioref">1984</a>)</span> conducted two experiments that asked participants to estimate the percentage of a smaller quantity to a larger quantity using graphics consisting of position, length, and angle comparisons. Results showed that the method of presentation affects estimation of numerical quantities, and thus that the choice of presentation is important in the design of charts.</p>
<p>(Lines vs.&nbsp;areas vs.&nbsp;volume)</p>
</section>
<section id="perception-of-3d-objects" class="level2">
<h2 class="anchored" data-anchor-id="perception-of-3d-objects">Perception of 3D Objects</h2>
<p>As humans, we perceive a 3D world <span class="citation" data-cites="martins2016">(<a href="#ref-martins2016" role="doc-biblioref">Martins 2016</a>)</span>. This limits our ability to perceive in higher dimensions, but allows us to view lower dimensions.</p>
<p>Early data visualizations made use of the same perceptual space that we use today, simply due to humans living in a three-dimensional world</p>
<p>For example, the Turin Papryrus Map was created around 1150 BC by Amennakhte (CITE). This map was drawn within 2-dimensions on papyrus and displays a region of Wadi Hammamat along with notable locations and features within the region. Another example is the quipu, which was a record keeping device used prominently by the Inca Empire, with use dating back to 2600 BC (CITE). The quipu used colored fiber cords and knots to record numerical entries in a 3-dimensional space. Over time, the methods of visualizing data changed, but still exist in 2- and 3-dimensional spaces.</p>
<p>(Grammar of graphics?)</p>
<p>Nearly every data visualization can be reduced into the mapping of values into visual elements, <span class="citation" data-cites="wilkinson2005">Wilkinson and Wills (<a href="#ref-wilkinson2005" role="doc-biblioref">2005</a>)</span></p>
<p>As technology developed, so did the ability to readily create data visualizations. (Hand drawn to printing to computer rendering)</p>
<p>(Testing of statistical graphics and key findings)</p>
<p>(Theory of 2d vs.&nbsp;3d, and purpose of dissertation)</p>
</section>
<section id="perception-of-3-dimensional-objects" class="level1">
<h1>Perception of 3-dimensional objects</h1>
<p>We live in a 3-dimensional (3D) world, where physical objects occupy the spaces around us. These objects exist in Euclidean space, having measurable lengths, widths, and heights <span class="citation" data-cites="euclides2008">(<a href="#ref-euclides2008" role="doc-biblioref">Euclides 2008, bk. 11</a>)</span>. Additionally, 3D objects also have environmental factors, such as material, texture, lighting, and position in space.</p>
<p>Human perception is a complex process, consisting of environmental and neurological factors <span class="citation" data-cites="johnson2018 welchman2016">(<a href="#ref-johnson2018" role="doc-biblioref">Johnson 2018</a>; <a href="#ref-welchman2016" role="doc-biblioref">Welchman 2016</a>)</span>.</p>
<p>(How image enters eye)</p>
<p>(Retina to brain/perception)</p>
<p>(2d images to perception)</p>
<p>(3d images to perception)</p>
<section id="state-of-2d-vs.-3d-graphics" class="level2">
<h2 class="anchored" data-anchor-id="state-of-2d-vs.-3d-graphics">State of 2D vs.&nbsp;3D graphics</h2>
</section>
</section>
<section id="section" class="level1 unnumbered">


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-brewer2012" class="csl-entry" role="listitem">
Brewer, Noel T., Melissa B. Gilkey, Sarah E. Lillie, Bradford W. Hesse, and Stacey L. Sheridan. 2012. <span>“Tables or Bar Graphs? Presenting Test Results in Electronic Medical Records.”</span> <em>Medical Decision Making</em> 32 (4): 545–53. <a href="https://doi.org/10.1177/0272989X12441395">https://doi.org/10.1177/0272989X12441395</a>.
</div>
<div id="ref-cleveland1984" class="csl-entry" role="listitem">
Cleveland, William S., and Robert McGill. 1984. <span>“Graphical Perception: Theory, Experimentation, and Application to the Development of Graphical Methods.”</span> <em>Journal of the American Statistical Association</em> 79 (387): 531–54. <a href="https://doi.org/10.1080/01621459.1984.10478080">https://doi.org/10.1080/01621459.1984.10478080</a>.
</div>
<div id="ref-croxton1932" class="csl-entry" role="listitem">
Croxton, Frederick E., and Harold Stein. 1932. <span>“Graphic Comparisons by Bars, Squares, Circles, and Cubes.”</span> <em>Journal of the American Statistical Association</em> 27 (177): 54–60. <a href="https://doi.org/10.1080/01621459.1932.10503227">https://doi.org/10.1080/01621459.1932.10503227</a>.
</div>
<div id="ref-dallenbach1963" class="csl-entry" role="listitem">
Dallenbach, Karl M. 1963. <span>“Tables Vs. Graphs as Means of Presenting Experimental Results.”</span> <em>The American Journal of Psychology</em> 76 (4): 700. <a href="https://doi.org/10.2307/1419727">https://doi.org/10.2307/1419727</a>.
</div>
<div id="ref-euclides2008" class="csl-entry" role="listitem">
Euclides. 2008. <em>Euclid’s Elements of Geometry: The Greek Text of J.L. Heiberg (1883 - 1885): From Euclidis Elementa, Edidit Et Latine Interpretatus Est I.L. Heiberg, in Aedibus B.G. Teubneri, 1883-1885</em>. Edited by Richard Fitzpatrick. Revised and corrected. s.l: s.n.
</div>
<div id="ref-heer2010" class="csl-entry" role="listitem">
Heer, Jeffrey, and Michael Bostock. 2010. <span>“CHI ’10: CHI Conference on Human Factors in Computing Systems.”</span> In, 203–12. Atlanta Georgia USA: ACM. <a href="https://doi.org/10.1145/1753326.1753357">https://doi.org/10.1145/1753326.1753357</a>.
</div>
<div id="ref-johnson2018" class="csl-entry" role="listitem">
Johnson, Scott P. 2018. <span>“Object Perception.”</span> In. Oxford University Press. <a href="https://doi.org/10.1093/acrefore/9780190236557.013.62">https://doi.org/10.1093/acrefore/9780190236557.013.62</a>.
</div>
<div id="ref-kosslyn1989" class="csl-entry" role="listitem">
Kosslyn, Stephen M. 1989. <span>“Understanding Charts and Graphs.”</span> <em>Applied Cognitive Psychology</em> 3 (3): 185225. <a href="https://doi.org/10.1002/acp.2350030302">https://doi.org/10.1002/acp.2350030302</a>.
</div>
<div id="ref-martins2016" class="csl-entry" role="listitem">
Martins, Rogério. 2016. <span>“Why Are We Not Able to See Beyond Three Dimensions?”</span> <em>The Mathematical Intelligencer</em> 38 (4): 46–51. <a href="https://doi.org/10.1007/s00283-016-9670-1">https://doi.org/10.1007/s00283-016-9670-1</a>.
</div>
<div id="ref-meyer1997" class="csl-entry" role="listitem">
Meyer, Joachim, David Shinar, and David Leiser. 1997. <span>“Multiple Factors That Determine Performance with Tables and Graphs.”</span> <em>Human Factors: The Journal of the Human Factors and Ergonomics Society</em> 39 (2): 268–86. <a href="https://doi.org/10.1518/001872097778543921">https://doi.org/10.1518/001872097778543921</a>.
</div>
<div id="ref-welchman2016" class="csl-entry" role="listitem">
Welchman, Andrew E. 2016. <span>“The Human Brain in Depth: How We See in 3D.”</span> <em>Annual Review of Vision Science</em> 2 (1): 345–76. <a href="https://doi.org/10.1146/annurev-vision-111815-114605">https://doi.org/10.1146/annurev-vision-111815-114605</a>.
</div>
<div id="ref-wickham2010" class="csl-entry" role="listitem">
Wickham, Hadley. 2010. <span>“A Layered Grammar of Graphics.”</span> <em>Journal of Computational and Graphical Statistics</em> 19 (1): 3–28. <a href="https://www.jstor.org/stable/25651297">https://www.jstor.org/stable/25651297</a>.
</div>
<div id="ref-wilkinson2005" class="csl-entry" role="listitem">
Wilkinson, Leland, and Graham Wills. 2005. <em>The Grammar of Graphics</em>. 2nd ed. Statistics and Computing. New York: Springer.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>